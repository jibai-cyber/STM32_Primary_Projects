#include "oledfont.h"
#include "oled1.h"

u8 OLED_GRAM[128][8]; 
/*引脚初始化*/
void OLED_I2C_Init(void)
{
     GPIO_InitTypeDef GPIO_InitStructure;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
 

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;  //这里注意引脚可能不同
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 
 OLED_W_SCL(1);
 OLED_W_SDA(1);
}

/**
  * @brief  I2C开始
  * @param  无
  * @retval 无
  */
void OLED_I2C_Start(void)
{
 OLED_W_SDA(1);
 OLED_W_SCL(1);
 OLED_W_SDA(0);
 OLED_W_SCL(0);
}

/**
  * @brief  I2C停止
  * @param  无
  * @retval 无
  */
void OLED_I2C_Stop(void)
{
 OLED_W_SDA(0);
 OLED_W_SCL(1);
 OLED_W_SDA(1);
}

/**
  * @brief  I2C发送一个字节
  * @param  Byte 要发送的一个字节
  * @retval 无
  */
void OLED_I2C_SendByte(uint8_t Byte)
{
 uint8_t i;
 for (i = 0; i < 8; i++)
 {
  OLED_W_SDA(Byte & (0x80 >> i));
  OLED_W_SCL(1);
  OLED_W_SCL(0);
 }
 OLED_W_SCL(1); //额外的一个时钟，不处理应答信号
 OLED_W_SCL(0);
}

/**
  * @brief  OLED写命令
  * @param  Command 要写入的命令
  * @retval 无
  */
void OLED_WriteCommand(uint8_t Command)
{
 OLED_I2C_Start();
 OLED_I2C_SendByte(0x78);  //从机地址
 OLED_I2C_SendByte(0x00);  //写命令
 OLED_I2C_SendByte(Command); 
 OLED_I2C_Stop();
}

/**
  * @brief  OLED写数据
  * @param  Data 要写入的数据
  * @retval 无
  */
void OLED_WriteData(uint8_t Data)
{
 OLED_I2C_Start();
 OLED_I2C_SendByte(0x78);  //从机地址
 OLED_I2C_SendByte(0x40);  //写数据
 OLED_I2C_SendByte(Data);
 OLED_I2C_Stop();
}

//更新显存到OLED  
void OLED_Refresh_Gram(void)
{
 u8 i,n;      
 for(i=0;i<8;i++)  
 {  
   OLED_WriteCommand(0xB0+i);     //设置Y位置
   OLED_WriteCommand(0x10); //设置X位置高4位
   OLED_WriteCommand(0x00);   //设置X位置低4位
  for(n=0;n<128;n++)
  {
   OLED_WriteData(OLED_GRAM[n][i]); 
  }
 }   
}

//画点 
//x:0~127
//y:0~63
//t:1 填充 0,清空       
void OLED_DrawPoint(u8 x,u8 y,u8 t)
{
 u8 pos,bx,temp=0;
 if(x>127||y>63)
 {
  return;//超出范围了.
 }
 pos=7-y/8;
 bx=y%8;
 temp=1<<(7-bx);
 if(t)
 {
  OLED_GRAM[x][pos]|=temp;
 }
 else OLED_GRAM[x][pos]&=~temp;     
}

//在指定位置显示一个字符,包括部分字符
//x:0~127
//y:0~63
//mode:0,反白显示;1,正常显示     
//size:选择字体 12/16/24
void OLED_ShowChar(u8 x,u8 y,u8 chr,u8 size,u8 mode)
{             
 u8 temp,t,t1;
 u8 y0=y;
 u8 csize=(size/8+((size%8)?1:0))*(size/2);  //得到字体一个字符对应点阵集所占的字节数，乘号前表示行字节，乘号后表示列字节 eg. size=16->需要16*8个字节来表示 size=12->需要16*6个字节来表示。行数如果不能被8整除则向上取整，因为oled显示方式为按列的，一字节一字节显示，列数则永远取一半
 chr=chr-' ';//得到偏移后的值   
    for(t=0;t<csize;t++)
    {   
  if(size==12)temp=asc2_1206[chr][t];    //调用1206字体
  else if(size==16)temp=asc2_1608[chr][t]; //调用1608字体
  else if(size==24)temp=asc2_2412[chr][t]; //调用2412字体
  else return;        //没有的字库
        for(t1=0;t1<8;t1++)     //每次取temp的最高位打印，一个循环打印8个bit就是一个byte，相当于打印了字库数组中的一个元素
  {
   if(temp&0x80)OLED_DrawPoint(x,y,mode);
   else OLED_DrawPoint(x,y,!mode);
   temp<<=1;
   y++;
   if((y-y0)==size) //注意看，这里如果取值为12，相当于打印到12行的时候会直接跳出循环，剩下的16-12=4行不会显示，相当于留白
   {
    y=y0;
    x++;
    break;
   }
  }    
    }          
}

void OLED_Show_ChineseChar(u8 x,u8 y,u8 num,u8 size,u8 mode)
{             
 u8 temp,t,t1;
 u8 y0=y;
 u8 csize=(size/8+((size%8)?1:0))*size;  //得到字体一个字符对应点阵集所占的字节数
    for(t=0;t<csize;t++)
    {   
        switch(size)
        {
            case 16: temp=Chinese_16[num][t]; break;
            case 24: temp=Chinese_24[num][t]; break;
            default: return;
        }
        for(t1=0;t1<8;t1++)     //每次取temp的最高位打印，一个循环打印8个bit就是一个byte，相当于打印了字库数组中的一个元素
  {
   if(temp&0x80)OLED_DrawPoint(x,y,mode);
   else OLED_DrawPoint(x,y,!mode);
   temp<<=1;
   y++;
   if((y-y0)==size)
   {
    y=y0;
    x++;
    break;
   }
  }    
    }          
}
//m^n函数
u32 mypow(u8 m,u8 n)
{
 u32 result=1;  
 while(n--)result*=m;    
 return result;
} 

//显示2个数字
//x,y :起点坐标  
//len :数字的位数
//size:字体大小
//mode:模式 0,填充模式;1,叠加模式
//num:数值(0~4294967295);      
void OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 size,u8 mode)
{          
 u8 t,temp;
 u8 enshow=0;         
 for(t=0;t<len;t++)
 {
  temp=(num/mypow(10,len-t-1))%10;
  if(enshow==0&&t<(len-1))
  {
   if(temp==0)
   {
    OLED_ShowChar(x+(size/2)*t,y,' ',size,mode);
    continue;
   }else enshow=1; 
     
  }
   OLED_ShowChar(x+(size/2)*t,y,temp+'0',size,mode); 
 }
} 
//显示字符串
//x,y:起点坐标  
//size:字体大小 
//*p:字符串起始地址 
void OLED_ShowString(u8 x,u8 y,const u8 *p,u8 size)
{ 
    while((*p<='~')&&(*p>=' '))//判断是不是非法字符!
    {       
        if(x>(128-(size/2))){x=0;y+=size;}
        if(y>(64-size)){y=x=0;OLED_Clear();}
        OLED_ShowChar(x,y,*p,size,1);  
        x+=size/2;
        p++;
    }  
 
}    

void OLED_Show_ChineseString(u8 x,u8 y,const u8 *p,u8 size) //中文数组最后一位必须是0，否则不好判断
{ 
    while(*p!=0)//判断是不是非法字符!这个0也用于中文数组结尾
    {       
        if(x>(128-size)){x=0;y+=size;}
        if(y>(64-size)){y=x=0;OLED_Clear();}
        OLED_Show_ChineseChar(x,y,*p,size,1);  
        x+=size;
        p++;
    }  
 
}    
/*graph_num表示第几个Graph叔祖，size见oledfont.h文件Graph数组*/
void OLED_ShowGraph(u8 x,u8 y,u8 Graph_num,u8 ysize,u16 size)
{
     u16 t;
     u8 y0=y,temp,t1;
     for(t=0;t<size;t++)
    {   
        switch(Graph_num)
        {
            case 1:temp = Graph1[t];break;
            case 2:temp = Graph2[t];break;
            case 3:temp = Graph3[t];break;
            case 4:temp = Graph4[t];break;
            case 5:temp = Graph5[t];break;
            default: break;
        }
           
        
            for(t1=0;t1<8;t1++)     
          {
           if(temp&0x80)OLED_DrawPoint(x,y,1);
           else OLED_DrawPoint(x,y,0);
           temp<<=1;
           y++;
           if((y-y0)==ysize)
           {
            y=y0;
            x++;
            break;
           }
          }    
    }   
}


//清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!!   
void OLED_Clear(void)  
{  
 u8 i,n;  
 for(i=0;i<8;i++)
 {
  for(n=0;n<128;n++)
  {
   OLED_GRAM[n][i]=0X00;  
  }
 }
 OLED_Refresh_Gram();//更新显示
}

/*局部清屏，从x0到x1，y0到y1，mode设置颜色*/
void OLED_Clear_part(u8 x0,u8 y0,u8 x1,u8 y1,u8 mode)
{
    u8 x,y;
//    if(x0>=x1) {x0 = x_b,x1 = x_s;}
//    else {x0 = x_s,x1 = x_b;}
//    
//    if(y0>=y1) {y0 = y_b,y1 = y_s;}
//    else {y0 = y_s,y1 = y_b;}
    for(x=x0;x<=x1;x++)
        for(y=y0;y<=y1;y++)
            OLED_DrawPoint(x,y,mode);
//    OLED_Refresh_Gram();
}
/*反转从x0到x1，y0到y1区域的颜色*/
void OLED_Opposite(u8 x0,u8 y0,u8 x1,u8 y1)
{
    u8 x,y,pos,bx,temp;
    for(x=x0;x<=x1;x++)
        for(y=y0;y<=y1;y++)
        {
           if(x>127||y>63)
          {
           return;//超出范围了.
          }
           pos=7-y/8;
           bx=y%8;
           temp=1<<(7-bx);
            if(OLED_GRAM[x][pos]&temp)
                OLED_DrawPoint(x,y,0);
            else OLED_DrawPoint(x,y,1);
        }
    OLED_Refresh_Gram();
}

u8 OLED_Judge(u8 x,u8 y)    //判断该位是黑还是白，黑为0，白为1，错误为2
{
    u8 pos,bx,temp;
    if(x>127||y>63)
      {
       return 2;//超出范围了.
      }
       pos=7-y/8;
       bx=y%8;
       temp=1<<(7-bx);
        if(OLED_GRAM[x][pos]&temp)
            return 1;
        else return 0;
}

//显示汉字
//x,y:起点坐标 
//num:字库中位数
//size:字体高度 
//mode:模式 0,填充模式;1,叠加模式
//void OLED_ShowChinese(u8 x,u8 y,u8 num,u8 size,u8 mode)
//{             
// u8 temp,t,t1;
// u8 y0=y;
// u8 csize=32;  //得到字体一个字符对应点阵集所占的字节数  
//    for(t=0;t<csize;t++)
//    {   
//  if(size==16)temp=Oled_Chinese[num][t]; //调用1608字体
//  else return;        //没有的字库
//        for(t1=0;t1<8;t1++)
//  {
//   if(temp&0x80)OLED_DrawPoint(x,y,mode);
//   else OLED_DrawPoint(x,y,!mode);
//   temp<<=1;
//   y++;
//   if((y-y0)==size)
//   {
//    y=y0;
//    x++;
//    break;
//   }
//  }    
//    }          
//}

/**
  * @brief  OLED初始化
  * @param  无
  * @retval 无
  */
void OLED_Init(void)
{
 uint32_t i, j;
 
 for (i = 0; i < 1000; i++)   //上电延时
 {
  for (j = 0; j < 1000; j++);
 }
 
 OLED_I2C_Init();   //端口初始化
 
 OLED_WriteCommand(0xAE); //关闭显示
 
 OLED_WriteCommand(0xD5); //设置显示时钟分频比/振荡器频率
 OLED_WriteCommand(0x80);
 
 OLED_WriteCommand(0xA8); //设置多路复用率
 OLED_WriteCommand(0x3F);
 
 OLED_WriteCommand(0xD3); //设置显示偏移
 OLED_WriteCommand(0x00);
 
 OLED_WriteCommand(0x40); //设置显示开始行
 
 OLED_WriteCommand(0xA1); //设置左右方向，0xA1正常 0xA0左右反置
 
 OLED_WriteCommand(0xC0); //设置上下方向，0xC8正常 0xC0上下反置

 OLED_WriteCommand(0xDA); //设置COM引脚硬件配置
 OLED_WriteCommand(0x12);
 
 OLED_WriteCommand(0x81); //设置对比度控制
 OLED_WriteCommand(0xCF);

 OLED_WriteCommand(0xD9); //设置预充电周期
 OLED_WriteCommand(0xF1);

 OLED_WriteCommand(0xDB); //设置VCOMH取消选择级别
 OLED_WriteCommand(0x30);

 OLED_WriteCommand(0xA4); //设置整个显示打开/关闭

 OLED_WriteCommand(0xA6); //设置正常/倒转显示

 OLED_WriteCommand(0x8D); //设置充电泵
 OLED_WriteCommand(0x14);

 OLED_WriteCommand(0xAF); //开启显示
  
 OLED_Clear();    //OLED清屏
}



